#!/usr/bin/env bash

# tmux requires unrecognized OSC sequences to be wrapped with DCS tmux;
# <sequence> ST, and for all ESCs in <sequence> to be replaced with ESC ESC. It
# only accepts ESC backslash for ST.
function print_osc() {
    if [[ $TERM == screen* ]] ; then
        printf "\033Ptmux;\033\033]"
    else
        printf "\033]"
    fi
}

# More of the tmux workaround described above.
function print_st() {
    if [[ $TERM == screen* ]] ; then
        printf "\a\033\\"
    else
        printf "\a"
    fi
}

# print_image filename inline base64contents
#   filename: Filename to convey to client
#   inline: 0 or 1
#   base64contents: Base64-encoded contents
function print_image() {
    print_osc
    printf '1337;File='
    if [[ -n "$1" ]]; then
      printf 'name='`echo -n "$1" | base64`";"
    fi
    if $(base64 --version 2>&1 | grep GNU > /dev/null)
    then
      BASE64ARG=-d
    else
      BASE64ARG=-D
    fi
    echo -n "$3" | base64 $BASE64ARG | wc -c | awk '{printf "size=%d",$1}'
    printf ";inline=$2"
    printf ":"
    echo -n "$3"
    print_st
    printf '\n'
}

print_image_url() {
  print_image "" 1 "$(base64 <(curl -s $(echo $1)))"
}

get_random_url () {
  raw_results=$(curl -s http://api.giphy.com/v1/gifs/random?api_key=dc6zaTOxFJmzC\&rating=pg)
  url=$(jq .data.image_original_url --raw-output <<< $raw_results)
}

get_url () {
  search_term=${1// /%20}
  raw_results=$(curl -s http://api.giphy.com/v1/gifs/search?q=$search_term\&api_key=dc6zaTOxFJmzC\&rating=pg)
  num_results=$(jq .pagination.count <<< $raw_results)
  if [ $num_results -ne 0 ]; then
    url=$(jq .data[$(jot -r 1 0 $(expr $num_results - 1))].images.original.url --raw-output <<< $raw_results)
  else
    echo "Terrible search term!"
    get_random_url
  fi
}

if [ $# -ne 0 ]; then
  get_url "$*"
else
  get_random_url
fi

print_image_url $url
